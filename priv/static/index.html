<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8" />
  <title>Dashboard</title>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bulma@0.9.3/css/bulma.min.css" />
</head>

<body>
  <div id="app"></div>
  <script src="https://unpkg.com/preact@10.11.2/dist/preact.min.js"></script>
  <script src="https://unpkg.com/preact@10.11.2/hooks/dist/hooks.umd.js"></script>
  <script type="text/javascript">
    const { h, render, Fragment } = preact;
    const { useState, useEffect, useRef } = preactHooks;

    function useWebSocket(url, onConnect = () => {}) {
      const [status, setStatus] = useState("Disconnected");
      const [messages, setMessages] = useState([]);
      const wsRef = useRef(null);
      let heartbeatInterval;

      useEffect(() => {
        let ws;
        let reconnectTimeout;

        function connect() {
          ws = new WebSocket(url);
          wsRef.current = ws;

          ws.onopen = () => {
            setStatus("Connected")
            if (reconnectTimeout) clearTimeout(reconnectTimeout);

            heartbeatInterval = setInterval(() => {
              if (ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify({ type: "heartbeat" }));
              }
            }, 5000);

            onConnect();
          };

          ws.onmessage = (event) => {
            try {
              const data = JSON.parse(event.data);
              setMessages((prev) => [...prev, data]);
            } catch (error) {
              console.error("Failed to parse message:", error);
            }
          };

          ws.onclose = () => {
            setStatus("Disconnected");
            reconnectTimeout = setTimeout(connect, 3000);

            if (heartbeatInterval) clearInterval(heartbeatInterval);
          };

          ws.onerror = (err) => {
            console.error("WebSocket error:", err);
          };
        }

        connect();

        return () => {
          if (ws) ws.close();
          if (reconnectTimeout) clearTimeout(reconnectTimeout);
        };
      }, [url]);

      const sendMessage = (msg) => {
        if (wsRef.current && wsRef.current.readyState === WebSocket.OPEN) {
          wsRef.current.send(JSON.stringify(msg));
        }
      };

      return { status, messages, sendMessage };
    }

    function Navbar({ title, status }) {
      const statusColor = status === "Connected" ? "success" : "danger";
      return h(
        "nav",
        { className: "navbar is-dark" },
        h("div", { className: "navbar-brand" },
          h("h1", { className: "navbar-item title is-4" }, title)
        ),
        h("div", { className: "navbar-end" },
          h("div", { className: `navbar-item has-text-${statusColor}` }, status)
        )
      );
    }

    function BehaviorRow({ behavior, onSelectActor }) {
      const [expanded, setExpanded] = useState(false);
      return h(Fragment, null, [
        h("tr", { key: behavior.name + "-data" }, [
          h("td", null, behavior.name),
          h("td", null, behavior.count),
          h("td", null,
            h("button",
              {
                className: "button is-small is-info",
                onClick: () => setExpanded((prev) => !prev)
              },
              expanded ? "Hide Actors" : "Show Actors"
            )
          )
        ]),
        expanded &&
        h("tr", { key: behavior.name + "-actors" }, [
          h("td", { colSpan: 3 },
            h("div", {
              style: { display: "flex", flexWrap: "wrap", gap: "0.25rem" }
            },
              behavior.actors.map((actor, idx) =>
                h("span", {
                  key: idx,
                  className: "tag is-info is-dark",
                  style: { cursor: "pointer" },
                  onClick: () => onSelectActor(actor)
                }, actor)
              )
            )
          )
        ])
      ]);
    }

    function BehaviorsPanel({ behaviors, onSelectActor }) {
      return h("div", { className: "box" }, [
        h("h2", { className: "title is-4" }, "Behaviors"),
        h("table", { className: "table is-fullwidth is-striped" }, [
          h("thead", null,
            h("tr", null, [
              h("th", null, "Name"),
              h("th", null, "Count"),
              h("th", null, "Actions")
            ])
          ),
          h("tbody", null,
            behaviors.map((behavior) =>
              h(BehaviorRow, { key: behavior.name, behavior, onSelectActor })
            )
          )
        ])
      ]);
    }

    function ActorCard({ actor }) {
      if (!actor) return null;
      return h("div", { className: "card", style: { marginTop: "1rem" } }, [
        h("header", { className: "card-header" },
          h("p", { className: "card-header-title" }, actor.name)
        ),
        h("div", { className: "card-content" },
          h("div", { className: "content" }, [
            h("p", null, "Behavior: " + actor.behavior),
            h("p", null, "Config: " + JSON.stringify(actor.config)),
            h("p", null, "Started: " + actor.started),
            h("p", null, "State: "),
            h("pre", null, JSON.stringify(actor.state, null, 2)),
          ])
        )
      ]);
    }

    function SimulationCard({ tick, duration, tps }) {
      return h("div", { className: "card", style: { marginTop: "1rem" } }, [
        h("header", { className: "card-header" },
          h("p", { className: "card-header-title" }, "Simulation")
        ),
        h("div", { className: "card-content" },
          h("div", {
            className: "content", style: { display: "flex", justifyContent: "space-around", flexWrap: "wrap", gap: "0.25rem" }
          }, [
            h("span", { className: "tag is-info" }, "Tick: " + tick),
            h("span", { className: "tag is-info" }, "Simulation time: " + duration),
            h("span", { className: "tag is-info" }, "TPS: " + tps),
          ])
        )
      ]);
    }

    function Dashboard() {
      const { status, messages, sendMessage } = useWebSocket("ws://localhost:4000/ws", () => {
        sendMessage({ type: "get_behaviors" });
        if (selectedActor) handleSelectActor(selectedActor);
      });
      const [actorStates, setActorStates] = useState([]);
      const [behaviors, setBehaviors] = useState([]);
      const [selectedActor, setSelectedActor] = useState(null);
      const [simulation, setSimulation] = useState({ tick: 0, duration: 0, tps: 0 });

      useEffect(() => {
        messages.forEach((msg) => {
          switch (msg.type) {
            case "simulation":
              setSimulation({
                tick: msg.data.tick_number,
                duration: msg.data.duration,
                tps: msg.data.tps
              });
              break;
            case "behaviors":
              setBehaviors(msg.behaviors);
              break;
            case "actor_state_update":
              setActorStates((prevStates) => {
                const index = prevStates.findIndex(
                  (actor) => actor.name === msg.actor_state.name
                );
                if (index !== -1) {
                  const newStates = [...prevStates];
                  newStates[index] = { ...msg.actor_state };
                  newStates.sort((a, b) => b.acting - a.acting);
                  return newStates;
                }
                return [...prevStates, { ...msg.actor_state }];
              });
              break;
            default:
              console.warn("Unhandled message type:", msg);
          }
        });
      }, [messages]);

      const handleSelectActor = (actor) => {
        setSelectedActor(actor);
        sendMessage({ type: "set_displayed_actor", actor });
      };

      const displayedActor = actorStates.find(a => a.name === selectedActor);

      return h("div", null, [
        h(Navbar, { title: "Dashboard", status }),
        h("section", { className: "section" },
          h("div", { className: "container" }, [
            h(SimulationCard, simulation),
            h(BehaviorsPanel, { behaviors, onSelectActor: handleSelectActor }),
            h(ActorCard, { actor: displayedActor })
          ])
        ),
      ]);
    }

    render(h(Dashboard), document.getElementById("app"));
  </script>
</body>

</html>